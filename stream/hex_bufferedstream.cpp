
// Copyright (C) 2014  Frode Roxrud Gill
// See LICENSE file for license

#ifdef __GNUG__
  #pragma implementation "hex_bufferedstream.h"
#endif

#ifdef WX_PRECOMP
# include "../pch.h"
#else
#endif

#include "hex_bufferedstream.h"


using namespace wxMailto;

const wxUint8 FROM_HEX[256] =
 {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //0x00-0x0F
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //0x10-0x1F	 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0x20-0x2F
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	0xFF, //0x30-0x3F
  0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0x40-0x4F
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0x50-0x5F
  0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0x60-0x6F
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0x70-0x7F
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0x80-0x8F
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0x90-0x9F
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0xA0-0xAF
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0xB0-0xBF
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0xC0-0xCF
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0xD0-0xDF
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	//0xE0-0xEF
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};//0xF0-0xFF

const wxUint8 TO_HEX[16] = {'0', '1', '2', '3', '4', '5', '6', '7',
	                          '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};


HexInputStream::HexInputStream(wxInputStream* stream, wxSizeT max_underflow_buffer_length, wxSizeT max_overflow_buffer_length)
: BufferedInputStream(stream, max_underflow_buffer_length, max_overflow_buffer_length)
{
}

void HexInputStream::Process(const wxUint8* src, wxSizeT src_length, wxSizeT& read_bytes,
                             wxUint8* dst, wxSizeT dst_length, wxSizeT& written_bytes,
                             wxBool eof)
{
	read_bytes = written_bytes = 0;
	if (!src || 0==src_length || !dst || 0==dst_length)
		return;

	wxUint8 ms_nibble, ls_nibble;
	while (written_bytes<dst_length && (read_bytes+1)<src_length)
	{
		ms_nibble = FROM_HEX[src[read_bytes]];
		ls_nibble = FROM_HEX[src[read_bytes+1]];
		if (0x0F<ms_nibble || 0x0F<ls_nibble) //Invalid hex byte
		{
			m_lasterror = wxSTREAM_READ_ERROR;
			break;
		}
		else
		{
			dst[written_bytes++] = (ms_nibble<<4)|ls_nibble;
			read_bytes += 2;
		}
	}
	
	if (eof && 1==(src_length-read_bytes))
	{
			m_lasterror = wxSTREAM_READ_ERROR;
	}
}


HexOutputStream::HexOutputStream(wxOutputStream* stream, wxSizeT max_underflow_buffer_length, wxSizeT max_overflow_buffer_length)
: BufferedOutputStream(stream, max_underflow_buffer_length, max_overflow_buffer_length)
{
}

void HexOutputStream::Process(const wxUint8* src, wxSizeT src_length, wxSizeT& read_bytes,
                              wxUint8* dst, wxSizeT dst_length, wxSizeT& written_bytes,
                              wxBool WXUNUSED(eof))
{
	read_bytes = written_bytes = 0;
	if (!src || 0==src_length || !dst || 0==dst_length)
		return;

	wxUint8 c;
	while ((written_bytes+1)<dst_length && read_bytes<src_length)
	{
		c = src[read_bytes++];
		dst[written_bytes++] = TO_HEX[(c&0xF0)>>4];
		dst[written_bytes++] = TO_HEX[c&0x0F];
	}
}
